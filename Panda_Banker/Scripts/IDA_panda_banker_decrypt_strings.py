import idautils
import string
import ida_bytes

# Max byte value
MAX_VALUE_1 = 0xFF

# Address memory limit to go backwards from an xref address of the 0x00064479 function
LIMIT = 0x100

# Decryption function address
DECRYPT_UNK_ADDRESS = 0x00064479

# Decryption constant
DECRYPTION_NUMBER = 0x4

# Array to store patched addresses to no patch them twice
patched_addresses = []


# Converts big endian value to little endian
def big_endian_to_little_endian_array(value):
	return [
		value & 0x000000FF,
		(value & 0x0000FF00) >> 0x8,
		(value & 0x00FF0000) >> 0x10,
		value >> 0x18
	]


# Checks if a value is hexadecimal (IDA Pro notation: 47A1C9h)
def check_if_hex(operand):
	return all(c in string.hexdigits for c in operand[0:-1]) and operand[-1] == "h"


# Key initialization function
def init_key():
	key = []
	for counter in range(0, 0x100):
		key.append(counter)
	key.append(0x0)

	return key


# Key generation algorithm
def generate_key(iv, number):
	key = init_key()
	i = 0x100
	previous = 0
	counter_1 = 0
	counter_2 = 0

	while i > 0:
		previous = (previous + iv[counter_2] + key[counter_1]) & MAX_VALUE_1
		key_byte = key[counter_1] & MAX_VALUE_1
		counter_2 = counter_2 + 1
		key[counter_1] = key[previous] & MAX_VALUE_1
		key[previous] = key_byte
		counter_1 = counter_1 + 1
		if counter_2 == number:
			counter_2 = 0
		i = i - 1

	return key


# Decryption algorithm
def decrypt_buffer(unk_buffer, key):
	counter_2 = 0
	aux_value = 0
	decrypted_buffer = bytearray()

	for enc_byte in unk_buffer:
		counter_2 = (counter_2 + 1) & MAX_VALUE_1
		key_byte = key[counter_2]
		aux_value = (aux_value + key[counter_2]) & MAX_VALUE_1
		key[counter_2] = key[aux_value]
		key[aux_value] = key_byte
		key_value = key[(key[counter_2] + key_byte) & MAX_VALUE_1]
		decrypted_buffer.append(enc_byte ^ key_value)

	return decrypted_buffer


# Get the value of "push" o "mov" instructions as integer to avoid python from adding the letter "L" (eg: 0xf78dd431L)
def get_value_from_instruction(instr_address):
	instruction_bytes = get_bytes(instr_address, ItemSize(instr_address))
	value = 0
	for index in range(1, ItemSize(instr_address)):
		value = value + (ord(instruction_bytes[index]) << (0x8 * (index - 1)))

	return value


# Gets the vale of a registry going backwards in a recursive way
# Get the value of EDX:
#	mov ecx, 1ah
#	mov edx, ecx
#	mov ebx, edx
def get_value_from_register(initial_instr_address, register):
	register_value = 0

	# Gets the instruction set from the current address minus 0x100 to the current address
	instructions = reversed(list(Heads(initial_instr_address - LIMIT, initial_instr_address)))
	for instr_address in instructions:
		# If the instruction is a "mov" plus the register we are looking for
		# Eg: expected register = "ECX" -> mov ecx, ANY
		if GetMnem(instr_address) == "mov" and GetOpnd(instr_address, 0) == register:
			operand = GetOpnd(instr_address, 1)
			if "offset" in operand or check_if_hex(operand) or operand.isdigit:
				# Get the value
				register_value = get_value_from_instruction(instr_address)
			else:
				# Look for recursively
				register_value = get_value_from_register(instr_address, GetOpnd(instr_address, 1))
			break

	return register_value


# Gets the address of the buffer to decrypt and its associated data (IV and size)
def get_decryption_data(xref_address):
	encrypted_buffer_address = ""
	little_endian_iv = 0
	buffer_size = 0

	push_counter = 0

	instructions = reversed(list(Heads(xref_address - LIMIT, xref_address)))
	for instr_address in instructions:
		# If the values have not been found
		if not encrypted_buffer_address or little_endian_iv == 0 or buffer_size == 0:
			# If the instruction is a "mov" plus the register in the destination operand is "ecx"
			# and the buffer address has not been found yet, we get this value
			if GetMnem(instr_address) == "mov" and GetOpnd(instr_address, 0) == "ecx" and not encrypted_buffer_address:
 				# If the operand of the source instruction is an offset, it is the address
				if "offset" in GetOpnd(instr_address, 1):
					encrypted_buffer_address = get_value_from_instruction(instr_address)
 				# If not, we look for the value in a recirsive way
				else:
					encrypted_buffer_address = get_value_from_register(instr_address, GetOpnd(instr_address, 1))
			# If the instruction is a "pop" we decrement the "push" counter
			elif GetMnem(instr_address) == "pop":
				push_counter = push_counter - 1
			# If the instruction is a "push" we increment the "push" counter and gets the values of the IV and the buffer_size
			elif GetMnem(instr_address) == "push":
				push_counter = push_counter + 1
				# If the push counter is equal 0 (it must be a pop prior this instruction), it is the size of the buffer
				if push_counter == 0 and buffer_size == 0:
 					operand = GetOpnd(instr_address, 0)
 					# If the operand of the instruction is a digit or an hex value, it is the size (if this value has not been found yet)
 					if check_if_hex(operand) or operand.isdigit:
 						buffer_size = get_value_from_instruction(instr_address)
 					# If not, we look for the value in a recirsive way
 					else:
 						buffer_size = get_value_from_register(instr_address, GetOpnd(instr_address, 0))
				# If the push counter is equal 1, it is the IV (if this value has not been found yet)
 				elif push_counter == 1 and little_endian_iv == 0:
					operand = GetOpnd(instr_address, 0)
 					# If the operand of the instruction is a an hex value, it is the IV
					if check_if_hex(operand):
						little_endian_iv = get_value_from_instruction(instr_address)
 					# If not, we look for the value in a recirsive way
					else:
						little_endian_iv = get_value_from_register(instr_address, GetOpnd(instr_address, 0))
			elif GetMnem(instr_address) == "lea" and GetOpnd(instr_address, 0) == "edx" and buffer_size == 0:
				buffer_size = ida_bytes.get_byte(instr_address + 2) + 1
			# If the instruction is a "mov" plus the register in the destination operand is "edx"
			# and the buffer size has not been found yet, we get this value
			elif GetMnem(instr_address) == "mov" and GetOpnd(instr_address, 0) == "edx" and buffer_size == 0:
				operand = GetOpnd(instr_address, 0)
 				# If the operand of the instruction is a digit or an hex value, it is the size
				if check_if_hex(operand) or operand.isdigit:
					buffer_size = get_value_from_instruction(instr_address)
 				# If not, we look for the value in a recirsive way
				else:
					buffer_size = get_value_from_register(instr_address, GetOpnd(instr_address, 1))
			# If the buffer size could not be obtained, we set it to 1, since it is real value in the binary
			elif GetMnem(instr_address) == "inc" and GetOpnd(instr_address, 0) == "edx" and buffer_size == 0:
				buffer_size = 1
		# If all values has been found, we stop the search
		else:
			break

	decryption_data = {
		"encrypted_buffer_address": str(encrypted_buffer_address),
		"little_endian_iv": str(little_endian_iv),
		"buffer_size": str(buffer_size)
	}

	return decryption_data


# Patches the unkwown buffer bytes with the decrypted buffer bytes and converts it to an ASCII string,
# also, to not patch twice the same buffer, we add its address to an array that we check prior patching any buffer
def patch_encrypted_buffer(encrypted_buffer_address, decrypted_buffer):
	if (encrypted_buffer_address not in patched_addresses):
		for index in range(0, len(decrypted_buffer)):
			ida_bytes.patch_byte(encrypted_buffer_address + index, decrypted_buffer[index])
		MakeStr(encrypted_buffer_address, encrypted_buffer_address + len(decrypted_buffer))
		patched_addresses.append(encrypted_buffer_address)


# Main function

print("Decrypting strings of Panda Banker...")

# Gets all xrefs from the decryption function (0x00064479 in our case)
xrefs_dec_unk = XrefsTo(DECRYPT_UNK_ADDRESS, 0)
for xref in xrefs_dec_unk:
	decryption_data = get_decryption_data(xref.frm)

	big_endian_iv = int(decryption_data["little_endian_iv"], 10)
	iv = big_endian_to_little_endian_array(big_endian_iv)

	buffer_size = int(decryption_data["buffer_size"], 10)

	encrypted_buffer_address = int(decryption_data["encrypted_buffer_address"], 10)
	encrypted_buffer = bytearray(get_bytes(encrypted_buffer_address, buffer_size))

	key = generate_key(iv, DECRYPTION_NUMBER)
	decrypted_buffer = decrypt_buffer(encrypted_buffer, key)

	patch_encrypted_buffer(encrypted_buffer_address, decrypted_buffer)
	
print("Strings decrypted!")

