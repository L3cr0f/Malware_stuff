# Panda Banker

This report shows the analysis and development process to automatically decrypt the strings of Panda Banker.

## Sample info

Original sample (packed)
	- MD5: eda0a631619abb9c38c6436d511bc67e
	- SHA1: ad707dab79853ae56ea4eba9b7d47251f8ca3a07
	- SHA256: 3057a943c961aee976a3b30ceafc42faa2bf157c7718008e6013875d251c072d

## Report

The sample will call the function at _0x00065758_, which will call the function at _0x000655B4_. This function will call some _WinAPI_ functions like _GetComputerNameW_ and _GetVersionExW_, so this function may perform some system information gathering.

Also, it calls several times to a function that we have called _decrypt_unk_ (_0x00064479_), since it seems to perform some kind of decryption process within. This function takes three important values, the initialization vector (_IV_) of the key generation algorithm, the buffer to decrypt and its length.

First, this function checks if the _CRC32_ value of the unknown buffer passed via _ECX_ is the expected one. Then, it will call the function that we have renamed to _decrypt_buffer_ (_0x0006415C_), where the decryption process takes place. This function receives the _IV_, the encrypted buffer and its length as arguments and also a numeric value passed at _EDX_, which will store the size, in bytes, of the _IV_.

![_IDA Pro_ _decrypt_buffer_](Pictures/1_ida_pro_1.png)

This function will call first a function that we have called _get_key_ (_0x00064072_), since it seems to perform some key generation prior the decryption process.

```
mov     esi, [esp+14h+key]	-> ESI = KEY
xor     ebx, ebx		-> EBX = 0
mov     eax, ebx		-> EAX = 0
mov     edi, esi		-> EDI = KEY
mov     [esi+100h], bx		-> KEY[0x100] = 0 (end of key string)
mov     ebp, 100h		-> EBP = 0x100

loc_64097:
mov     [edi], al		-> KEY [counter_1] = counter_2 -> counter_1 = counter_2
inc     eax			-> counter_1 = counter_1 + 1
inc     edi			-> counter_2 = counter_2 + 1
cmp     ax, bp			-> AX = BP (0x100 iterations)
jb      short loc_64097

mov     cl, bl			-> CL = 0
mov     edi, esi		-> EDI = KEY = [0x0, 0x1, 0x2, ..., 0xFE, 0xFF, 0x0]

loc_640A4:
mov     esi, [esp+18h+iv]	-> ESI = IV
mov     dl, [edi]		-> DL = KEY[counter_1]
movzx   eax, bl			-> EAX = counter_2
mov     al, [eax+esi]		-> AL = IV[counter_2]
mov     esi, [esp+18h+key]	-> ESI = KEY
add     al, dl			-> AL = IV[counter_2] + KEY[counter_1]
add     cl, al			-> CL = previous + IV[counter_2] + KEY[counter_1] (previous initial value = 0)
inc     bl			-> counter_2 = counter_2 + 1
mov     [esp+18h+previous], cl	-> previous = previous + IV[counter_2] + KEY[counter_1] (previous initial value = 0)
movzx   ecx, cl			-> ECX = previous + IV[counter_2] + KEY[counter_1] (previous initial value = 0)
mov     al, [ecx+esi]		-> AL = KEY[previous] (previous initial value = 0)
mov     [edi], al		-> KEY[counter_1] = KEY[previous] (previous initial value = 0)      
inc     edi			-> counter_1 = counter_1 + 1
mov     [ecx+esi], dl		-> KEY[previous] = KEY[counter_1]
xor     edx, edx		-> EDX = 0
movzx   ecx, bl			-> ECX = counter_2
cmp     cx, [esp+18h+number]	-> CX == number (0x4 or 0x20)
mov     cl, [esp+18h+previous]	-> CL = previous (previous initial value = 0)
movzx   eax, bl			-> EAX = counter_2
cmovnz  edx, eax		-> IF ZF == 0 -> EDX = counter_2
mov     bl, dl			-> counter_2 = counter_2 (or 0 if ZF is set)
sub     ebp, 1			-> EBP = EBP - 1 (EBP initial value = 0x100)
jnz     short loc_640A4
```

Based on that, we have developed the following _Python_ functions:

```
MAX_VALUE_1 = 0xFF

def init_key():
	key = []
	for counter in range(0, 0x100):
		key.append(counter)
	key.append(0x0)

	return key


def generate_key(iv, number):
	key = init_key()
	i = 0x100
	previous = 0
	counter_1 = 0
	counter_2 = 0

	while i > 0:
		previous = (previous + iv[counter_2] + key[counter_1]) & MAX_VALUE_1
		key_byte = key[counter_1] & MAX_VALUE_1
		counter_2 = counter_2 + 1
		key[counter_1] = key[previous] & MAX_VALUE_1
		key[previous] = key_byte
		counter_1 = counter_1 + 1
		if counter_2 == number:
			counter_2 = 0
		i = i - 1

	return key
```

After that, the binary will call the function at _0x000640EE_, which we have renamed to _xor_decryption_, since it seems to perform the decryption routine. Let's dig into it.

```
mov     edi, [esp+14h+key]		-> EDI = KEY
xor     ebp, ebp			-> EBP = 0 = counter_1
mov     bl, [edi+100h]			-> BL = KEY[0x100] = 0
mov     bh, [edi+101h]			-> BH = KEY[0x101] = undefined (we assume is 0)

loc_64114:
inc     bl				-> BL = BL + 1
movzx   esi, bl				-> ESI = BL = counter_2
mov     dl, [esi+edi]			-> DL = KEY[counter_2]
add     bh, dl				-> AUX = AUX + KEY[counter_2]
movzx   ecx, bh				-> ECX = AUX
mov     al, [ecx+edi]			-> AL = KEY[AUX]
mov     [esi+edi], al			-> KEY[counter_2] = KEY[AUX]
mov     [ecx+edi], dl			-> KEY[AUX] = KEY[counter_2]
movzx   eax, byte ptr [esi+edi]		-> EAX = KEY[counter_2] & 0xFF
movzx   ecx, dl				-> ECX = KEY[counter_2]
add     ecx, eax			-> ECX = KEY[counter_2] + (KEY[counter_2] & 0xFF)
movzx   eax, cl				-> EAX = (KEY[counter_2] + (KEY[counter_2] & 0xFF)) & 0xFF
mov     ecx, [esp+18h+unknown_buffer]	-> ECX = UNK_BUFFER
mov     al, [eax+edi]			-> AL = KEY[(KEY[counter_2] + (KEY[counter_2] & 0xFF)) & 0xFF] & 0xFF
xor     [ecx+ebp], al			-> UNK_BUFFER[counter_1] = UNK_BUFFER[counter_1] ^ KEY[(BH + KEY[counter_2] + KEY[counter_2]) & 0xFF] & & 0xFF
inc     ebp				-> counter_1 = counter_1 + 1
cmp     ebp, [esp+18h+length]		-> counter < length
jb      short loc_64114
```

This algorithm has been integrated in the following _Python_ function:

```
def decrypt_buffer(unk_buffer, key):
	counter_2 = 0
	aux_value = 0
	decrypted_buffer = ""

	for enc_byte in unk_buffer:
		counter_2 = (counter_2 + 1) & MAX_VALUE_1
		key_byte = key[counter_2]
		aux_value = (aux_value + key[counter_2]) & MAX_VALUE_1
		key[counter_2] = key[aux_value]
		key[aux_value] = key_byte
		key_value = key[(key[counter_2] + key_byte) & MAX_VALUE_1]
		decrypted_buffer = decrypted_buffer + chr(enc_byte ^ key_value)

	return decrypted_buffer
```

All these functions make the _Python_ script at "Scripts/decrypt_strings.py". We have included a couple of encrypted buffers to decrypt them as an example:

```
$ python3 decrypt_strings.py

The decrypted buffers are:
 - C:\
 - InstallDate
```

Now, we have developed a _IDAPython_ script that decrypts all the strings and replaces the encrypted buffers with the decrypted ones (some buffers may not be decrypted, if one function call is used to decrypt several strings, in these cases, we have to decrypt them manually). This script can be found at "Scripts/IDA_panda_banker_decrypt_strings.py".

After the execution of the previous script, we can see the strings of the sample in plain text (some of them may require manual decryption or a different script approach).

![_IDA Pro_ decrypted strings](Pictures/1_ida_pro_2.png)

Later on, we discovered that algorithm was indeed _RC4_, so all this process could be done in an easier way, but it had not been as fun as it was :).